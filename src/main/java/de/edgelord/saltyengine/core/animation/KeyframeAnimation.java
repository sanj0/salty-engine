/*
 * Copyright 2019 Malte Dostal
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.edgelord.saltyengine.core.animation;

import java.util.*;

/**
 * An abstract implementation of the
 * <code>Keyframe animation</code> concept.
 */
public abstract class KeyframeAnimation {

    // v = u0 * (1 - x)^3 + 3 * u1 * (1 - x)^2 * x + 3 * u2 * (1 - x) * x^2 + u3 * x^3

    /**
     * The list of Keyframes
     */
    private List<Keyframe> keyframes;

    /**
     * A map of relative values to timecode generated by {@link
     * #calculateAnimation()}
     */
    private Map<Integer, Float> animation = new HashMap<>();

    /**
     * The timecode of the last {@link Keyframe}
     */
    private int end = 0;

    /**
     * The current frame, manipulable by {@link #setCurrentFrame(int)} and
     * {@link #restart()}
     */
    private int currentFrame = -1;

    /**
     * Stores whether there were changes made to {@link #keyframes the list of
     * KeyFrames} since the last {@link #calculateAnimation() calculation} or
     * not
     */
    private boolean unCalculatedChanges = false;

    /**
     * A constructor.
     *
     * @param keyframes the initial list of
     *                  <code>Keyframe</code>s
     */
    public KeyframeAnimation(final List<Keyframe> keyframes) {
        this.keyframes = keyframes;
        add(0, 0);
    }

    /**
     * A constructor to initialize and empty
     * <code>KeyframeAnimation</code>
     */
    public KeyframeAnimation() {
        this(new ArrayList<>());
    }

    /**
     * A constructor that initializes the {@link #keyframes} list with the given
     * vararg of {@link Keyframe}s.
     *
     * @param frames the {@link Keyframe frames} to initialize the animation
     *               with
     */
    public KeyframeAnimation(final Keyframe... frames) {
        this(Arrays.asList(frames));
    }

    /**
     * Important: This method only returns a delta value!
     *
     * @return the next delta-step of the linear keyframe animation
     */
    public float nextDelta() {
        if (unCalculatedChanges) {
            System.out.println("Warning: There are un-calculated changes in a KeyframeAnimation!");
        }

        if (!animationEnded()) {
            currentFrame++;
            return animation.get(currentFrame);
        } else {
            // If there is a request out of the available timeline, there should be no delta, so return 0
            return 0f;
        }
    }

    /**
     * Fills the {@link #animation} with timecode-to-delta values.
     */
    public abstract void calculateAnimation();

    /**
     * Sorts the {@link #keyframes} by their timecode and sets the {@link
     * #end}.
     */
    protected void prepareAnimation() {
        currentFrame = -1;
        unCalculatedChanges = false;
        keyframes.sort(Comparator.comparingInt(Keyframe::getTimecode));
        this.end = keyframes.get(keyframes.size() - 1).getTimecode();
        getAnimation().clear();
    }

    /**
     * Return <code>true</code> if and only if the
     * <br> {@link #currentFrame} is smaller than
     * the {@link #end} - 1
     *
     * @return <code>true</code> if the animation
     * has ended and therefore reached the last frame and <code>false</code> if
     * not.
     */
    public boolean animationEnded() {
        return !(currentFrame < end - 1);
    }

    /**
     * Adds the given <code>Keyframe</code> to the {@link #keyframes list}.
     *
     * @param keyframe the new <code>Keyframe</code>
     */
    public void add(final Keyframe keyframe) {
        keyframes.add(keyframe);
        unCalculatedChanges = true;
    }

    /**
     * Adds a new <code>Keyframe</code> to the {@link #keyframes list} with the
     * given timecode and value.
     *
     * @param timecode the timecode for the new
     *                 <code>Keyframe</code>
     * @param value    the value of the new
     *                 <code>Keyframe</code>
     */
    public void add(final int timecode, final float value) {
        keyframes.add(new Keyframe(timecode, value));
        unCalculatedChanges = true;
    }

    public void remove(final Keyframe keyframe) {
        keyframes.remove(keyframe);
    }

    public void removeByTimecode(final int timing) {
        keyframes.removeIf(keyframe -> keyframe.getTimecode() == timing);
    }

    public void removeByKey(final float key) {
        keyframes.removeIf(keyframe -> keyframe.getValue() == key);
    }

    public void restart() {
        currentFrame = -1;
    }

    protected Map<Integer, Float> getAnimation() {
        return animation;
    }

    protected void setAnimation(final Map<Integer, Float> animation) {
        this.animation = animation;
    }

    /**
     * Gets {@link #keyframes}.
     *
     * @return the value of {@link #keyframes}
     */
    public List<Keyframe> getKeyframes() {
        return keyframes;
    }

    /**
     * Sets {@link #keyframes}.
     *
     * @param keyframes the new value of {@link #keyframes}
     */
    public void setKeyframes(final List<Keyframe> keyframes) {
        this.keyframes = keyframes;
    }

    /**
     * Gets {@link #currentFrame}.
     *
     * @return the value of {@link #currentFrame}
     */
    public int getCurrentFrame() {
        return currentFrame;
    }

    /**
     * Sets {@link #currentFrame}.
     *
     * @param currentFrame the new value of {@link #currentFrame}
     */
    public void setCurrentFrame(final int currentFrame) {
        this.currentFrame = currentFrame;
    }
}
